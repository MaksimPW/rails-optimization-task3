# Case-study оптимизации

## Актуальная проблема

В нашем проекте возникла серьёзная проблема.

Страница расписаний формируется не эффективно, механизм перезагрузки расписаний из файла занимает очень много времени(больше минуты)

## Задачи


### №1 Сократить время выполнения импорта данных

### №2 Оптимизировать загрузку отображения расписаний

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время исполнения rake таски и страницы с рейсами

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за N:

- пока не выстроил

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался:

- пока ничем не воспользовался

Вот какие проблемы удалось найти и решить

### Шаг №0

Прогнал rake reload_json для всех файлов в fixtures, записал результаты
large.json отрабатывал слишком долго, не стал ждать
Буду ориентироваться на small.json, результат: 30 секунд

Решил сразу воспользоваться советом использовать гем `activerecord-import`

Поставил его, применил для импорта Trip
После прогона make reload_small время работы сократилось и составило 26 сек

### Шаг №1

В этом шаге решил сконцентрироваться на загрузке данных из json в базу

#### Подготовка:

Добавил в проект
- pghero
- rack-mini-profiler
- memory-profiler
- bullet
- rspec-benchmark
- rspec-sqlimit

Перенес код по импорту данных из rake task в отдельный интерактор `ImportData`

Для того, чтобы лучше разобраться в коде и защитить его, написал rspec тесты и сделал рефакторинг

#### Профилирование:

С помощью тестов `rspec-sqlimit` смог увидеть количество запросов, которые я делаю в базу

Как оказалось, использовать `activerecord-import` только лишь для Trip было не так корректно, так как к другим таблицам все равно было очень много запросов.

#### Изменения:

Сделал хранение всей информации в хеше. Это позволит нам не делать так много запросов SELECT к базе, чтобы найти запись.

Использовал метод `import` из гема `activerecord-import` для других моделей:
Service, Bus, City

#### Результаты:

|                  |ДО                        |ПОСЛЕ                     |
|------------------|--------------------------|--------------------------|
| example.json     | 0.547757 сек             | 0.257931 сек             |
| large.json       | очень долго              | 56 сек                   |
| medium.json      | 229 сек                  | 10 сек                   |
| small.json       | 30 сек                   | 2.990186 сек             |

#### Выводы:

Нагрузка на память выросла за счет того, что все данные стали хранится в хешах(MEMORY USAGE: 1067 MB)
Но я смог сократить время работы за счет уменьшения количества запросов в базу.
Так что по метрике задача №1 была выполнена

Думаю, что можно сократить и показатели по памяти, но тогда нужно будет отказаться от `activerecord-import` и стримить записи сразу в бд

### Шаг №3

В этом шаге решил сконцентрироваться на оптимизации загрузки страницы с рейсами

Импортировал данные из файла large.json в базу

#### 1.

Страница с рейсами загрузилась за 24158.2 ms
`bullet` сразу дал подсказку 'USE eager loading detected' для `app/views/trips/_trip.html.erb`

Результаты rack-mini-profiler так же указали на то, что здесь происходит очень много запросов на получении информации по каждому автобусу
```
Rendering: trips/index.html.erb	10686.2	+18.8	650 sql	1815.9
```

Добавил `includes([:bus])` в запрос на получение @trips

#### 2.

Дальше `bullet` стал жаловаться на такую же проблему N+1 и для `services`

Изменил запрос на получение @trips, чтобы дополнительно загружать еще и services:
```
@trips = Trip.preload(bus: :services).where(from: @from, to: @to).order(:start_time).load
```

После этого ActiveRecord больше не был главной точкой роста

Результаты rack-mini-profiler:
```
Rendering: trips/index.html.erb	6081.0	+2326.9	1 sql	9.3
```

Логи Rails:
```
Completed 200 OK in 17511ms (Views: 15219.8ms | ActiveRecord: 100.8ms)
```

#### 3.

По логам и результатам профилировщика rack-mini-profiler можно было заметить, что теперь основное время тратилось на загрузку вьюх

Решил избавиться от partials и перенести весь код из них в trips/index.html.erb
После изменений страница стала загружаться быстрее:
```
Completed 200 OK in 6027ms (Views: 3736.2ms | ActiveRecord: 56.0ms)
```

#### 4.

Нашел в trips/index.html.erb вызов count, заменил его на size
Время загрузки ActiveRecord изменилось в лучшую сторону:
```
Completed 200 OK in 6313ms (Views: 4103.4ms | ActiveRecord: 43.3ms)
```

#### Результаты:

|ДО                        |ПОСЛЕ                     |
|--------------------------|--------------------------|
| 24158.2 ms               | 6313.3 ms                |

#### Выводы:


## Результаты

### rake reload_json

|                  |ДО                        |ПОСЛЕ                     |
|------------------|--------------------------|--------------------------|
| example.json     | 0.547757                 | -                        |
| large.json       | очень долго              | -                        |
| medium.json      | 229 сек                  | -                        |
| small.json       | 30 сек                   | -                        |

### Заметки

#### Совет: как посчитать кол-во строк в файле
```
wc -l data_large.rb # (3250940)  total line count
```

#### Совет: как создать меньший файл из большего, оставив перевые N строк
```
head -n N data_large.txt > dataN.txt
```

## Защита от регрессии производительности

Пока ничего не сделано